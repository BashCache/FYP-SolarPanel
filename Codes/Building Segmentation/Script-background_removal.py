# -*- coding: utf-8 -*-
"""Script - Background Removal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17L5kHYKadxudPUPvSLQ9azjOPTW_mexK

## **BG Subtraction**

- Separate the building rooftops from the entire background and remove the building so that it can be used in the next step to annotate using the CVAT tool.
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import glob
import os

# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

train_path_image = '/content/drive/MyDrive/airs-minisample/patch/'
train_path_label = '/content/drive/MyDrive/airs-minisample/patch/'

image_numbers = [36, 84, 97, 173, 174, 196, 215, 216, 217, 259, 260, 282, 304, 389, 411, 445, 458, 490, 539, 540, 602, 683, 708, 784, 792, 937, 979, 995, 1043, 74, 168, 194, 273, 677, 503, 606, 53, 209, 372, 512, 822, 852, 1038]

"""- cv2.imread will convert image to numpy array

**IDEA**

- Draw bounding boxes in segmented image. ✅
- Store the bounded boxes result in a vector. ✅
- Fill the bounding box with a color (Color filling - so that the entire bounding box is filled with white color): named as seg_with_bounded_box. ✅
- Perform background subtraction: original aerial imagery - seg_with_bounded_box. ✅
- Crop regions based on the bounded box stored in step 2. ✅


-- For now try this: In case, resolution is not so good we can try zooming first and then cropping

### **Draw bounding boxes on the binary segmented mask & perform color filling**

- Convert the image to grayscale.
- Apply threshold.
- Get contours.
- Fill bounding box with color
- Store {x,y,w,h} in a vector of list
"""

def draw_bb_color_filling(img, img_mask):

  # convert to grayscale
  gray = cv2.cvtColor(img_mask, cv2.COLOR_BGR2GRAY)

  # threshold
  thresh = cv2.threshold(gray, 128, 255, cv2.THRESH_BINARY)[1]

  # get contours
  result = img_mask.copy()
  seg_with_bounded_box = img_mask.copy()
  contours = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  contours = contours[0] if len(contours) == 2 else contours[1]
  print("No of identified buildings: {0}".format(len(contours)))
  bb = []

  for cntr in contours:
      x,y,w,h = cv2.boundingRect(cntr)
      cv2.rectangle(result, (x, y), (x+w, y+h), (0, 0, 255), 2)
      cv2.rectangle(seg_with_bounded_box, (x, y), (x+w, y+h), (255, 255, 255), -1)
      bb.append([x,y,w,h])

  print(bb)   

  plt.imshow(seg_with_bounded_box)
  plt.title('Segmented mask with bounding box and color filling')
  plt.show()

  return bb, seg_with_bounded_box

"""### **Background Subtraction**

"""

# Post-process
def background_subtraction(img, seg_with_bounded_box):
  
  new_seg_image_gray = cv2.cvtColor(seg_with_bounded_box, cv2.COLOR_RGB2GRAY) # Convert the mask to grayscale
  img_np = np.asarray(img) # Convert the PIL image to a numpy array
  masked_out = cv2.bitwise_and(img_np, img_np, mask = new_seg_image_gray) # Blend the mask
  masked_out_new = np.where(masked_out != 0, masked_out, 255) # Remove the background
  
  plt.imshow(masked_out_new)
  plt.title('Masked-out Image')
  plt.show()
  
  return masked_out_new

"""### **Cropping & Saving Buidings**"""

def crop_and_save(bb, masked_out_new, building_name):

  for i in range(len(bb)):
    x = bb[i][0]
    y = bb[i][1]
    w = bb[i][2]
    h = bb[i][3]
    # print('x, y, w, h: ', x,y,w,h)
    # try using Image.crop()
    # masked_out_new.crop((x,y,w,h))
    # cv2.imwrite('/content/drive/MyDrive/airs-minisample/crop-saved/'+str(i)+'.tif', masked_out_new.crop((x,y,w,h)))
    # print('/content/drive/MyDrive/airs-minisample/crop-saved/'+ building_name + '_' + str(i) + '.tif')
    cv2.imwrite('/content/drive/MyDrive/airs-minisample/crop-saved/'+ building_name + '_' + str(i) + '.tif', masked_out_new[y:y+h, x:x+w])
    # fig = plt.figure(figsize=(15,15))
    # fig.add_subplot(len(bb), 1, i+1)
    # plt.imshow(masked_out_new[y:y+h, x:x+w])
    # plt.plot()

# len(image_numbers)
for i in range(3,5,1):

  building_name ='christchurch_' + str(image_numbers[i])
  train_path_image_i = train_path_image + building_name + '.tif'
  train_path_label_i = train_path_image + building_name + '_vis.tif'
  print('Path names: {0}, {1}'.format(train_path_image_i, train_path_label_i))

  img = cv2.imread(train_path_image_i, cv2.IMREAD_COLOR)
  img_mask = cv2.imread(train_path_label_i, cv2.IMREAD_COLOR)
  print(img.shape, img_mask.shape, type(img_mask))

  bb, seg_with_bounded_box = draw_bb_color_filling(img, img_mask)
  masked_out_new = background_subtraction(img, seg_with_bounded_box)
  crop_and_save(bb, masked_out_new, building_name)

"""### **Zoom and then crop & save image**

**Zooming without loosing aspect ratio:** https://stackoverflow.com/questions/69050464/zoom-into-image-with-cv2
"""

def zoom_at(img, x, y, zoom):
    w, h = img.size
    zoom2 = zoom * 50
    img = img.crop((x - w / zoom2, y - h / zoom2, 
                    x + w / zoom2, y + h / zoom2))
    return img.resize((w, h), Image.LANCZOS)

img_zoom = Image.open("/content/drive/MyDrive/airs-minisample/train/image/christchurch_10.tif")
for i in range(len(bb)):
  x = bb[i][0]
  y = bb[i][1]
  w = bb[i][2]
  h = bb[i][3]
  print('x, y, w, h: ', x,y,w,h)

  image_bb_zoomed = zoom_at(img_zoom, x+w//2, y+h//2, 1.5)
  image_bb_zoomed.save('/content/drive/MyDrive/airs-minisample/crop-saved/zoom-'+str(i)+'.tif')
  # cv2.imwrite('/content/drive/MyDrive/airs-minisample/crop-saved/zoom-'+str(i)+'.tif', image_bb_zoomed)